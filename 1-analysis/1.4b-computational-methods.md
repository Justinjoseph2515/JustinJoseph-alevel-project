# 1.4b Computational Methods

## Thinking Abstractly and Visualization

Abstraction is the methodology of removing unnecessary details from an issue whilst allowing you to focus on the core and important aspect of the issue . For my purpose abstraction would be used to help me remove unnecessary detail that will not affect my game's performance (such as the graphics, sound, and dialogue). Thus I would shift my focus to the core aspects of my game. This includes the following:

* the design of the character will be simple whilst serving only a functional purpose&#x20;
* the layout of the level will basic and simple until other aspects of the game are created as such as the character and the enemy
* have a simple input control system for the players this could by limiting the number of input that player has for the time being
* having a overall simple game the user to interact with this include: the menu, the design as well of the component of the game .



## Thinking Ahead

Thinking Ahead means to plan out a process from start to end before commencing upon it. This is vital for a successful project as it allows you to foresee what the final game is going to look like. Thus allowing you to take relevant step to get to completion.  An issue arise when the next step is not consider correctly as this could lead to the subsequent step being miss placed which would lead to  the plan to falling apart.

I aim to prevent this from happening by a strong start to my game ; i aim to set up the basic in a roadbust manner before the next subsequent steps are put in place . To ensure that all of the step that  has been put down and is going to be put down is correct i would think it through before taking any action , i would also see the impact it could have on the game whilst write the code for the game .i would also think of way on how i can improve what i can programming to aid myself down the line.&#x20;





## Thinking Procedurally and Decomposition

Decomposition is the process of taking an overwhelming problem and then breaking the problem down into sub-problems after which the sub-problems can be solved individually whilst ranking each problem by importance. This will enable us to solve the overwhelming problem at a manageable rate.

I intend to use this very method throughout the development phases of my coding project. As mentioned in my last paragraph I will achieve this by splitting the whole game into individual components (for example the movement of the player, coin system, obstacle, and so on) after which I will deal with each component on an individual level by further breaking the component into individual tasks, thereafter enabling me to complete each task in a step by step action. Thus splitting the whole game into manageable levels will enable me to complete the game in an efficient and timely manner. All of the components of the game will be mentioned in the success criteria and in the design frame, whilst the task will be mentioned in each development cycle.



## Thinking Logically

Thinking logically is the act of analysing a problem and providing a solid solution to the situation. This is very appreciable with my game, ensuring that the game follows a logical process to provide a good game experience for the player.&#x20;

## Thinking Concurrently

Thinking concurrently is the process of accomplishing more than two tasks simultaneously in a given time frame. Completing multiple tasks in one go can increase the efficiency of the program whilst saving time, which enables the PC to shift its focus onto more power-intensive aspects of the game. For the purposes of my game the example of two more tasks that can be run "behind the scenes "  simultaneously could be :

* When the player comes in contact with an obstacle, the game checks if contact has been made whilst reducing the health of the player at the same time.
* Checking if the player had fallen off whilst on a moving platform.&#x20;
* When the player and the enemy are in the same frame but both would be able to move independently of each other.

&#x20; &#x20;

